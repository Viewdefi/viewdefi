{"version":3,"file":"sortable.esm.js","sources":["../../utils/src/browser-info.ts","../../utils/src/utils.ts","../../sortable/src/PluginManager.ts","../../sortable/src/EventDispatcher.ts","../../sortable/src/Sortable.ts","../../plugins/swap/src/index.ts","../../sortable/src/Animation.ts","../../plugins/multi-drag/src/index.ts","../../plugins/auto-scroll/src/index.ts","../../plugins/on-spill/src/index.ts","../src/modular-default.ts"],"sourcesContent":["function userAgent(pattern) {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));\n  }\n}\n\nexport const IE11OrLess = userAgent(\n  /(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i\n);\nexport const Edge = userAgent(/Edge/i);\nexport const FireFox = userAgent(/firefox/i);\nexport const Safari =\n  userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nexport const IOS = userAgent(/iP(ad|od|hone)/i);\nexport const ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n","import { IE11OrLess } from \"./browser-info\";\nimport Sortable from \"../../sortable/src/Sortable\";\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/ el, /**String*/ selector) {\n  if (!selector) return;\n\n  selector[0] === \">\" && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType\n    ? el.host\n    : el.parentNode;\n}\n\nfunction closest(\n  /**HTMLElement*/ el,\n  /**String*/ selector,\n  /**HTMLElement*/ ctx,\n  includeCTX\n) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (\n        (selector != null &&\n          (selector[0] === \">\"\n            ? el.parentNode === ctx && matches(el, selector)\n            : matches(el, selector))) ||\n        (includeCTX && el === ctx)\n      ) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while ((el = getParentOrHost(el)));\n  }\n\n  return null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? \"add\" : \"remove\"](name);\n    } else {\n      let className = (\" \" + el.className + \" \")\n        .replace(R_SPACE, \" \")\n        .replace(\" \" + name + \" \", \" \");\n      el.className = (className + (state ? \" \" + name : \"\")).replace(\n        R_SPACE,\n        \" \"\n      );\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  let style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, \"\");\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf(\"webkit\") === -1) {\n        prop = \"-webkit-\" + prop;\n      }\n\n      style[prop] = val + (typeof val === \"string\" ? \"\" : \"px\");\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  let appliedTransforms = \"\";\n  if (typeof el === \"string\") {\n    appliedTransforms = el;\n  } else {\n    do {\n      //@ts-ignore\n      let transform = css(el, \"transform\");\n\n      if (transform && transform !== \"none\") {\n        appliedTransforms = transform + \" \" + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  const matrixFn =\n    window.DOMMatrix ||\n    window.WebKitCSSMatrix ||\n    //@ts-ignore\n    window.CSSMatrix ||\n    //@ts-ignore\n    window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    let list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  let scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(\n  el,\n  relativeToContainingBlock,\n  relativeToNonStaticParent,\n  undoScale,\n  container\n) {\n  if (!el.getBoundingClientRect && el !== window) return;\n\n  let elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if (\n    (relativeToContainingBlock || relativeToNonStaticParent) &&\n    el !== window\n  ) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (\n          container &&\n          container.getBoundingClientRect &&\n          //@ts-ignore\n          (css(container, \"transform\") !== \"none\" ||\n            (relativeToNonStaticParent &&\n              //@ts-ignore\n              css(container, \"position\") !== \"static\"))\n        ) {\n          let containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -=\n            //@ts-ignore\n            containerRect.top + parseInt(css(container, \"border-top-width\"));\n          left -=\n            //@ts-ignore\n            containerRect.left + parseInt(css(container, \"border-left-width\"));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n\n          break;\n        }\n        /* jshint boss:true */\n      } while ((container = container.parentNode));\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    //@ts-ignore\n    let elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n\n      width /= scaleX;\n      height /= scaleY;\n\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height,\n  };\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  let parent = getParentAutoScrollElement(el, true),\n    //@ts-ignore\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    //@ts-ignore\n    let parentSideVal = getRect(parent)[parentSide],\n      visible;\n\n    if (parentSide === \"top\" || parentSide === \"left\") {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n\n    if (parent === getWindowScrollingElement()) break;\n\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options) {\n  let currentChild = 0,\n    i = 0,\n    children = el.children;\n\n  while (i < children.length) {\n    if (\n      children[i].style.display !== \"none\" &&\n      //@ts-ignore\n      children[i] !== Sortable.ghost &&\n      //@ts-ignore\n      children[i] !== Sortable.dragged &&\n      closest(children[i], options.draggable, el, false)\n    ) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n\n    i++;\n  }\n  return null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n  let last = el.lastElementChild;\n\n  while (\n    last &&\n    //@ts-ignore\n    (last === Sortable.ghost ||\n      //@ts-ignore\n      css(last, \"display\") === \"none\" ||\n      (selector && !matches(last, selector)))\n  ) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n  let index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while ((el = el.previousElementSibling)) {\n    if (\n      el.nodeName.toUpperCase() !== \"TEMPLATE\" &&\n      //@ts-ignore\n      el !== Sortable.clone &&\n      (!selector || matches(el, selector))\n    ) {\n      index++;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n  let offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      //@ts-ignore\n      let elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n  for (let i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n  let elem = el;\n  let gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (\n      elem.clientWidth < elem.scrollWidth ||\n      elem.clientHeight < elem.scrollHeight\n    ) {\n      //@ts-ignore\n      let elemCSS = css(elem);\n      if (\n        (elem.clientWidth < elem.scrollWidth &&\n          (elemCSS.overflowX == \"auto\" || elemCSS.overflowX == \"scroll\")) ||\n        (elem.clientHeight < elem.scrollHeight &&\n          (elemCSS.overflowY == \"auto\" || elemCSS.overflowY == \"scroll\"))\n      ) {\n        if (!elem.getBoundingClientRect || elem === document.body)\n          return getWindowScrollingElement();\n\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while ((elem = elem.parentNode));\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return (\n    Math.round(rect1.top) === Math.round(rect2.top) &&\n    Math.round(rect1.left) === Math.round(rect2.left) &&\n    Math.round(rect1.height) === Math.round(rect2.height) &&\n    Math.round(rect1.width) === Math.round(rect2.width)\n  );\n}\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      let args = arguments,\n        _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  //@ts-ignore\n  let Polymer = window.Polymer;\n  //@ts-ignore\n  let $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, \"position\", \"absolute\");\n  css(el, \"top\", rect.top);\n  css(el, \"left\", rect.left);\n  css(el, \"width\", rect.width);\n  css(el, \"height\", rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, \"position\", \"\");\n  css(el, \"top\", \"\");\n  css(el, \"left\", \"\");\n  css(el, \"width\", \"\");\n  css(el, \"height\", \"\");\n}\n\nconst expando = \"Sortable\" + new Date().getTime();\n\nexport {\n  on,\n  off,\n  matches,\n  getParentOrHost,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  indexOfObject,\n  getParentAutoScrollElement,\n  extend,\n  isRectEqual,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  clone,\n  setRect,\n  unsetRect,\n  expando,\n};\n","let plugins = [];\n\nconst defaults = {\n  initializeByDefault: true,\n};\n\nconst pluginManager = {\n  mount(plugin) {\n    // Set default static properties\n    for (let option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.push(plugin);\n  },\n  pluginEvent(eventName, sortable, evt) {\n    this.eventCanceled = false;\n    evt.cancel = () => {\n      this.eventCanceled = true;\n    };\n    const eventNameGlobal = eventName + \"Global\";\n    plugins.forEach((plugin) => {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (\n        sortable.options[plugin.pluginName] &&\n        sortable[plugin.pluginName][eventName]\n      ) {\n        sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n      }\n    });\n  },\n  initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach((plugin) => {\n      const pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n\n      let initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      Object.assign(defaults, initialized.defaults);\n    });\n\n    for (let option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      let modified = this.modifyOption(\n        sortable,\n        option,\n        sortable.options[option]\n      );\n      if (typeof modified !== \"undefined\") {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties(name, sortable) {\n    let eventProperties = {};\n    plugins.forEach((plugin) => {\n      if (typeof plugin.eventProperties !== \"function\") return;\n      Object.assign(\n        eventProperties,\n        plugin.eventProperties.call(sortable[plugin.pluginName], name)\n      );\n    });\n\n    return eventProperties;\n  },\n  modifyOption(sortable, name, value) {\n    let modifiedValue;\n    plugins.forEach((plugin) => {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (\n        plugin.optionListeners &&\n        typeof plugin.optionListeners[name] === \"function\"\n      ) {\n        modifiedValue = plugin.optionListeners[name].call(\n          sortable[plugin.pluginName],\n          value\n        );\n      }\n    });\n\n    return modifiedValue;\n  },\n};\n\nexport default pluginManager;\n","import { expando, IE11OrLess, Edge } from \"../../utils/src\";\nimport PluginManager from \"./PluginManager\";\n\nexport default function dispatchEvent({\n  sortable,\n  rootEl,\n  name,\n  targetEl,\n  cloneEl,\n  toEl,\n  fromEl,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  originalEvent,\n  putSortable,\n  extraEventProperties,\n}) {\n  sortable = sortable || (rootEl && rootEl[expando]);\n  if (!sortable) return;\n\n  let evt,\n    options = sortable.options,\n    onName = \"on\" + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  let allEventProperties = {\n    ...extraEventProperties,\n    ...PluginManager.getEventProperties(name, sortable),\n  };\n  for (let option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n","import { version } from \"../package.json\";\nimport AnimationStateManager from \"./Animation\";\nimport PluginManager from \"./PluginManager\";\nimport dispatchEvent from \"./EventDispatcher\";\n/**\n * @todo import as namespace: import * as utils from \"../../utils/src\"\n */\nimport {\n  on,\n  off,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  extend,\n  throttle,\n  scrollBy,\n  clone,\n  expando,\n  IE11OrLess,\n  Edge,\n  FireFox,\n  Safari,\n  IOS,\n  ChromeForAndroid,\n} from \"../../utils/src\";\n\nlet pluginEvent = function (\n  eventName,\n  sortable,\n  //@ts-ignore\n  { evt: originalEvent, ...data } = {}\n) {\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {\n    dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    dragStarted: moved,\n    putSortable,\n    //@ts-ignore\n    activeSortable: Sortable.active,\n    originalEvent,\n\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n\n    cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown() {\n      cloneHidden = false;\n    },\n\n    dispatchSortableEvent(name) {\n      _dispatchEvent({ sortable, name, originalEvent });\n    },\n\n    ...data,\n  });\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent({\n    putSortable,\n    cloneEl,\n    targetEl: dragEl,\n    rootEl,\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n    ...info,\n  });\n}\n\nlet dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [], // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nconst documentExists = typeof document !== \"undefined\",\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? \"cssFloat\" : \"float\",\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable =\n    documentExists &&\n    !ChromeForAndroid &&\n    !IOS &&\n    \"draggable\" in document.createElement(\"div\"),\n  supportCssPointerEvents = (function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    let el = document.createElement(\"x\");\n    el.style.cssText = \"pointer-events:auto\";\n    return el.style.pointerEvents === \"auto\";\n  })(),\n  _detectDirection = function (el, options) {\n    //@ts-ignore\n    let elCSS = css(el),\n      elWidth =\n        parseInt(elCSS.width) -\n        parseInt(elCSS.paddingLeft) -\n        parseInt(elCSS.paddingRight) -\n        parseInt(elCSS.borderLeftWidth) -\n        parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      //@ts-ignore\n      firstChildCSS = child1 && css(child1),\n      //@ts-ignore\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth =\n        firstChildCSS &&\n        parseInt(firstChildCSS.marginLeft) +\n          parseInt(firstChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child1).width,\n      secondChildWidth =\n        secondChildCSS &&\n        parseInt(secondChildCSS.marginLeft) +\n          parseInt(secondChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child2).width;\n\n    if (elCSS.display === \"flex\") {\n      return elCSS.flexDirection === \"column\" ||\n        elCSS.flexDirection === \"column-reverse\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (elCSS.display === \"grid\") {\n      return elCSS.gridTemplateColumns.split(\" \").length <= 1\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (child1 && firstChildCSS.float && firstChildCSS.float !== \"none\") {\n      let touchingSideChild2 =\n        firstChildCSS.float === \"left\" ? \"left\" : \"right\";\n\n      return child2 &&\n        (secondChildCSS.clear === \"both\" ||\n          secondChildCSS.clear === touchingSideChild2)\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    return child1 &&\n      (firstChildCSS.display === \"block\" ||\n        firstChildCSS.display === \"flex\" ||\n        firstChildCSS.display === \"table\" ||\n        firstChildCSS.display === \"grid\" ||\n        (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === \"none\") ||\n        (child2 &&\n          elCSS[CSSFloatProperty] === \"none\" &&\n          firstChildWidth + secondChildWidth > elWidth))\n      ? \"vertical\"\n      : \"horizontal\";\n  },\n  _dragElInRowColumn = function (dragRect, targetRect, vertical) {\n    let dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n\n    return (\n      dragElS1Opp === targetS1Opp ||\n      dragElS2Opp === targetS2Opp ||\n      dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2\n    );\n  },\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function (x, y) {\n    let ret;\n    sortables.some((sortable) => {\n      //@ts-ignore\n      if (lastChild(sortable)) return;\n\n      //@ts-ignore\n      let rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally =\n          x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically =\n          y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return (ret = sortable);\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function (options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        let sameGroup =\n          to.options.group.name &&\n          from.options.group.name &&\n          to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === \"clone\") {\n          return value;\n        } else if (typeof value === \"function\") {\n          return toFn(value(to, from, dragEl, evt), pull)(\n            to,\n            from,\n            dragEl,\n            evt\n          );\n        } else {\n          let otherGroup = (pull ? to : from).options.group.name;\n\n          return (\n            value === true ||\n            (typeof value === \"string\" && value === otherGroup) ||\n            (value.join && value.indexOf(otherGroup) > -1)\n          );\n        }\n      };\n    }\n\n    let group = {};\n    let originalGroup = options.group;\n\n    if (!originalGroup || typeof originalGroup != \"object\") {\n      originalGroup = { name: originalGroup };\n    }\n\n    //@ts-ignore\n    group.name = originalGroup.name;\n    //@ts-ignore\n    group.checkPull = toFn(originalGroup.pull, true);\n    //@ts-ignore\n    group.checkPut = toFn(originalGroup.put);\n    //@ts-ignore\n    group.revertClone = originalGroup.revertClone;\n\n    options.group = group;\n  },\n  _hideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"none\");\n    }\n  },\n  _unhideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"\");\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists) {\n  document.addEventListener(\n    \"click\",\n    function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    },\n    true\n  );\n}\n\nlet nearestEmptyInsertDetectEvent = function (evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      let event = {};\n      for (let i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      //@ts-ignore\n      event.target = event.rootEl = nearest;\n      //@ts-ignore\n      event.preventDefault = void 0;\n      //@ts-ignore\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nlet _checkOutsideTargetEl = function (evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw `Sortable: \\`el\\` must be an HTMLElement, not ${{}.toString.call(\n      el\n    )}`;\n  }\n\n  this.el = el; // root element\n  this.options = options = Object.assign({}, options);\n\n  // Export instance\n  el[expando] = this;\n\n  let defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? \">li\" : \">*\",\n    swapThreshold: 1, // percentage; 0 <= x <= 1\n    invertSwap: false, // invert always\n    invertedSwapThreshold: null, // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function () {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: \"sortable-ghost\",\n    chosenClass: \"sortable-chosen\",\n    dragClass: \"sortable-drag\",\n    ignore: \"a, img\",\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer, dragEl) {\n      dataTransfer.setData(\"Text\", dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: \"data-id\",\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold:\n      (Number.parseInt ? Number : window).parseInt(\n        //@ts-ignore\n        window.devicePixelRatio,\n        10\n      ) || 1,\n    forceFallback: false,\n    fallbackClass: \"sortable-fallback\",\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer:\n      //@ts-ignore\n      Sortable.supportPointer !== false && \"PointerEvent\" in window,\n    emptyInsertThreshold: 5,\n  };\n\n  //@ts-ignore\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (let name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (let fn in this) {\n    if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, \"pointerdown\", this._onTapStart);\n  } else {\n    on(el, \"mousedown\", this._onTapStart);\n    on(el, \"touchstart\", this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, \"dragover\", this);\n    on(el, \"dragenter\", this);\n  }\n\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store &&\n    options.store.get &&\n    this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  Object.assign(this, AnimationStateManager());\n}\n\nSortable.prototype = /** @lends Sortable.prototype */ {\n  constructor: Sortable,\n\n  _isOutsideThisEl: function (target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n\n  _getDirection: function (evt, target) {\n    return typeof this.options.direction === \"function\"\n      ? this.options.direction.call(this, evt, target, dragEl)\n      : this.options.direction;\n  },\n\n  _onTapStart: function (/** Event|TouchEvent */ evt) {\n    if (!evt.cancelable) return;\n    let _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch =\n        (evt.touches && evt.touches[0]) ||\n        (evt.pointerType && evt.pointerType === \"touch\" && evt),\n      target = (touch || evt).target,\n      originalTarget =\n        (evt.target.shadowRoot &&\n          ((evt.path && evt.path[0]) ||\n            (evt.composedPath && evt.composedPath()[0]))) ||\n        target,\n      filter = options.filter;\n\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n\n    if (\n      (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||\n      options.disabled\n    ) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (\n      !this.nativeDraggable &&\n      Safari &&\n      target &&\n      target.tagName.toUpperCase() === \"SELECT\"\n    ) {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === \"function\") {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: \"filter\",\n          targetEl: target,\n          toEl: el,\n          fromEl: el,\n        });\n        pluginEvent(\"filter\", _this, { evt });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(\",\").some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: \"filter\",\n            targetEl: target,\n            fromEl: el,\n            toEl: el,\n          });\n          pluginEvent(\"filter\", _this, { evt });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n\n  _prepareDragStart: function (\n    /** Event */ evt,\n    /** Touch */ touch,\n    /** HTMLElement */ target\n  ) {\n    let _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      //@ts-ignore\n      let dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n\n      //@ts-ignore\n      Sortable.dragged = dragEl;\n\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY,\n      };\n\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n\n      dragEl.style[\"will-change\"] = \"all\";\n\n      dragStartFn = function () {\n        pluginEvent(\"delayEnded\", _this, { evt });\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: \"choose\",\n          originalEvent: evt,\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(\",\").forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n\n      on(ownerDocument, \"dragover\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"mousemove\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"touchmove\", nearestEmptyInsertDetectEvent);\n\n      on(ownerDocument, \"mouseup\", _this._onDrop);\n      on(ownerDocument, \"touchend\", _this._onDrop);\n      on(ownerDocument, \"touchcancel\", _this._onDrop);\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent(\"delayStart\", this, { evt });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (\n        options.delay &&\n        (!options.delayOnTouchOnly || touch) &&\n        (!this.nativeDraggable || !(Edge || IE11OrLess))\n      ) {\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        on(ownerDocument, \"mouseup\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchend\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchcancel\", _this._disableDelayedDrag);\n        on(ownerDocument, \"mousemove\", _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, \"touchmove\", _this._delayedDragTouchMoveHandler);\n        options.supportPointer &&\n          on(ownerDocument, \"pointermove\", _this._delayedDragTouchMoveHandler);\n\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n\n  _delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/ e) {\n    let touch = e.touches ? e.touches[0] : e;\n    if (\n      Math.max(\n        Math.abs(touch.clientX - this._lastX),\n        Math.abs(touch.clientY - this._lastY)\n      ) >=\n      Math.floor(\n        this.options.touchStartThreshold /\n          ((this.nativeDraggable && window.devicePixelRatio) || 1)\n      )\n    ) {\n      this._disableDelayedDrag();\n    }\n  },\n\n  _disableDelayedDrag: function () {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n\n  _disableDelayedDragEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, \"mouseup\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchend\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchcancel\", this._disableDelayedDrag);\n    off(ownerDocument, \"mousemove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"touchmove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n\n  _triggerDragStart: function (/** Event */ evt, /** Touch */ touch) {\n    touch = touch || (evt.pointerType == \"touch\" && evt);\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, \"pointermove\", this._onTouchMove);\n      } else if (touch) {\n        on(document, \"touchmove\", this._onTouchMove);\n      } else {\n        on(document, \"mousemove\", this._onTouchMove);\n      }\n    } else {\n      on(dragEl, \"dragend\", this);\n      on(rootEl, \"dragstart\", this._onDragStart);\n    }\n\n    try {\n      //@ts-ignore\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          //@ts-ignore\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n\n  _dragStarted: function (fallback, evt) {\n    let _this = this;\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent(\"dragStarted\", this, { evt });\n\n      if (this.nativeDraggable) {\n        on(document, \"dragover\", _checkOutsideTargetEl);\n      }\n      let options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n\n      //@ts-ignore\n      Sortable.active = this;\n\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: \"start\",\n        originalEvent: evt,\n      });\n    } else {\n      this._nulling();\n    }\n  },\n\n  _emulateDragOver: function () {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      let target = document.elementFromPoint(\n        touchEvt.clientX,\n        touchEvt.clientY\n      );\n      let parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(\n          touchEvt.clientX,\n          touchEvt.clientY\n        );\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            let inserted;\n\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent,\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        } while (\n          /* jshint boss:true */\n          //@ts-ignore\n          (parent = parent.parentNode)\n        );\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n\n  _onTouchMove: function (/**TouchEvent*/ evt) {\n    if (tapEvt) {\n      let options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset =\n          PositionGhostAbsolutely &&\n          ghostRelativeParent &&\n          getRelativeScrollOffset(ghostRelativeParent),\n        dx =\n          (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]\n            : 0) /\n            (scaleX || 1),\n        dy =\n          (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]\n            : 0) /\n            (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      //@ts-ignore\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (\n          fallbackTolerance &&\n          Math.max(\n            Math.abs(touch.clientX - this._lastX),\n            Math.abs(touch.clientY - this._lastY)\n          ) < fallbackTolerance\n        ) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy,\n          };\n        }\n\n        let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;\n\n        css(ghostEl, \"webkitTransform\", cssMatrix);\n        css(ghostEl, \"mozTransform\", cssMatrix);\n        css(ghostEl, \"msTransform\", cssMatrix);\n        css(ghostEl, \"transform\", cssMatrix);\n\n        lastDx = dx;\n        lastDy = dy;\n\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n\n  _appendGhost: function () {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      let container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (\n          //@ts-ignore\n          css(ghostRelativeParent, \"position\") === \"static\" &&\n          //@ts-ignore\n          css(ghostRelativeParent, \"transform\") === \"none\" &&\n          ghostRelativeParent !== document\n        ) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (\n          ghostRelativeParent !== document.body &&\n          ghostRelativeParent !== document.documentElement\n        ) {\n          if (ghostRelativeParent === document)\n            ghostRelativeParent = getWindowScrollingElement();\n\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(\n          ghostRelativeParent\n        );\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n\n      css(ghostEl, \"transition\", \"\");\n      css(ghostEl, \"transform\", \"\");\n\n      css(ghostEl, \"box-sizing\", \"border-box\");\n      css(ghostEl, \"margin\", 0);\n      css(ghostEl, \"top\", rect.top);\n      css(ghostEl, \"left\", rect.left);\n      css(ghostEl, \"width\", rect.width);\n      css(ghostEl, \"height\", rect.height);\n      css(ghostEl, \"opacity\", \"0.8\");\n      css(ghostEl, \"position\", PositionGhostAbsolutely ? \"absolute\" : \"fixed\");\n      css(ghostEl, \"zIndex\", \"100000\");\n      css(ghostEl, \"pointerEvents\", \"none\");\n\n      //@ts-ignore\n      Sortable.ghost = ghostEl;\n\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(\n        ghostEl,\n        \"transform-origin\",\n        (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +\n          \"% \" +\n          (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +\n          \"%\"\n      );\n    }\n  },\n\n  _onDragStart: function (/**Event*/ evt, /**boolean*/ fallback) {\n    let _this = this;\n    let dataTransfer = evt.dataTransfer;\n    let options = _this.options;\n\n    pluginEvent(\"dragStart\", this, { evt });\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n\n    pluginEvent(\"setupClone\", this);\n    //@ts-ignore\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n\n      cloneEl.draggable = false;\n      cloneEl.style[\"will-change\"] = \"\";\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      //@ts-ignore\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent(\"clone\", _this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: \"clone\",\n      });\n    });\n\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, \"mouseup\", _this._onDrop);\n      off(document, \"touchend\", _this._onDrop);\n      off(document, \"touchcancel\", _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = \"move\";\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, \"drop\", _this);\n\n      // #1276 fix:\n      css(dragEl, \"transform\", \"translateZ(0)\");\n    }\n\n    awaitingDragStarted = true;\n\n    _this._dragStartId = _nextTick(\n      _this._dragStarted.bind(_this, fallback, evt)\n    );\n    on(document, \"selectstart\", _this);\n\n    moved = true;\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"none\");\n    }\n  },\n\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function (/**Event*/ evt) {\n    let el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      //@ts-ignore\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, {\n        evt,\n        isOwner,\n        axis: vertical ? \"vertical\" : \"horizontal\",\n        revert,\n        dragRect,\n        targetRect,\n        canSort,\n        fromSortable,\n        target,\n        completed,\n        onMove(target, after) {\n          return onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            //@ts-ignore\n            getRect(target),\n            evt,\n            after\n          );\n        },\n        changed,\n        ...extra,\n      });\n    }\n\n    // Capture animation state\n    function capture() {\n      //@ts-ignore\n      dragOverEvent(\"dragOverAnimationCapture\");\n\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent(\"dragOverCompleted\", { insertion });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : activeSortable.options.ghostClass,\n            false\n          );\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        //@ts-ignore\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n          //@ts-ignore\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          //@ts-ignore\n          dragOverEvent(\"dragOverAnimationComplete\");\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (\n        (target === dragEl && !dragEl.animated) ||\n        (target === el && !target.animated)\n      ) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n      return (completedFired = true);\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      //@ts-ignore\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: \"change\",\n        toEl: el,\n        newIndex,\n        newDraggableIndex,\n        originalEvent: evt,\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n\n    //@ts-ignore\n    dragOverEvent(\"dragOver\");\n    //@ts-ignore\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (\n      dragEl.contains(evt.target) ||\n      (target.animated && target.animatingX && target.animatingY) ||\n      _this._ignoreWhileAnimating === target\n    ) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (\n      activeSortable &&\n      !options.disabled &&\n      (isOwner\n        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n        : putSortable === this ||\n          ((this.lastPutMode = activeGroup.checkPull(\n            this,\n            activeSortable,\n            dragEl,\n            evt\n          )) &&\n            group.checkPut(this, activeSortable, dragEl, evt)))\n    ) {\n      vertical = this._getDirection(evt, target) === \"vertical\";\n\n      //@ts-ignore\n      dragRect = getRect(dragEl);\n\n      //@ts-ignore\n      dragOverEvent(\"dragOverValid\");\n      //@ts-ignore\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n\n        this._hideClone();\n\n        //@ts-ignore\n        dragOverEvent(\"revert\");\n\n        //@ts-ignore\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      let elLastChild = lastChild(el, options.draggable);\n\n      if (\n        !elLastChild ||\n        (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)\n      ) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // assign target only if condition is true\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          //@ts-ignore\n          targetRect = getRect(target);\n        }\n\n        if (\n          onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            targetRect,\n            evt,\n            !!target\n          ) !== false\n        ) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        //@ts-ignore\n        targetRect = getRect(target);\n        let direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(\n            (dragEl.animated && dragEl.toRect) || dragRect,\n            (target.animated && target.toRect) || targetRect,\n            vertical\n          ),\n          side1 = vertical ? \"top\" : \"left\",\n          scrolledPastTop =\n            isScrolledPast(target, \"top\", \"top\") ||\n            isScrolledPast(dragEl, \"top\", \"top\"),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert =\n            (!differentRowCol && options.invertSwap) || differentLevel;\n        }\n\n        direction = _getSwapDirection(\n          evt,\n          target,\n          targetRect,\n          vertical,\n          differentRowCol ? 1 : options.swapThreshold,\n          options.invertedSwapThreshold == null\n            ? options.swapThreshold\n            : options.invertedSwapThreshold,\n          isCircumstantialInvert,\n          lastTarget === target\n        );\n\n        let sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          //@ts-ignore\n          let dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (\n            sibling &&\n            //@ts-ignore\n            (css(sibling, \"display\") === \"none\" || sibling === ghostEl)\n          );\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n\n        lastDirection = direction;\n\n        let nextSibling = target.nextElementSibling,\n          after = false;\n\n        after = direction === 1;\n\n        let moveVector = onMove(\n          rootEl,\n          el,\n          dragEl,\n          dragRect,\n          target,\n          targetRect,\n          evt,\n          after\n        );\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(\n              dragEl,\n              after ? nextSibling : target\n            );\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(\n              scrolledPastTop,\n              0,\n              scrollBefore - scrolledPastTop.scrollTop\n            );\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(\n              //@ts-ignore\n              targetBeforeFirstSwap - getRect(target)[side1]\n            );\n          }\n          changed();\n\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n\n  _ignoreWhileAnimating: null,\n\n  _offMoveEvents: function () {\n    off(document, \"mousemove\", this._onTouchMove);\n    off(document, \"touchmove\", this._onTouchMove);\n    off(document, \"pointermove\", this._onTouchMove);\n    off(document, \"dragover\", nearestEmptyInsertDetectEvent);\n    off(document, \"mousemove\", nearestEmptyInsertDetectEvent);\n    off(document, \"touchmove\", nearestEmptyInsertDetectEvent);\n  },\n\n  _offUpEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n\n    off(ownerDocument, \"mouseup\", this._onDrop);\n    off(ownerDocument, \"touchend\", this._onDrop);\n    off(ownerDocument, \"pointerup\", this._onDrop);\n    off(ownerDocument, \"touchcancel\", this._onDrop);\n    off(document, \"selectstart\", this);\n  },\n\n  _onDrop: function (/**Event*/ evt) {\n    let el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    pluginEvent(\"drop\", this, {\n      evt,\n    });\n\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n\n    clearInterval(this._loopId);\n\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, \"drop\", this);\n      off(el, \"dragstart\", this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"\");\n    }\n\n    css(dragEl, \"transform\", \"\");\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        // Remove clone(s)\n        cloneEl &&\n          cloneEl.parentNode &&\n          cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, \"dragend\", this);\n        }\n\n        _disableDraggable(dragEl);\n        dragEl.style[\"will-change\"] = \"\";\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : this.options.ghostClass,\n            false\n          );\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: \"unchoose\",\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt,\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"add\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: \"remove\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"sort\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: \"sort\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: \"update\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: \"sort\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n            }\n          }\n        }\n\n        //@ts-ignore\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: \"end\",\n            toEl: parentEl,\n            originalEvent: evt,\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n\n  _nulling: function () {\n    pluginEvent(\"nulling\", this);\n    //@ts-ignore\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n\n  handleEvent: function (/**Event*/ evt) {\n    switch (evt.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(evt);\n        break;\n\n      case \"dragenter\":\n      case \"dragover\":\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n\n      case \"selectstart\":\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function () {\n    let order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function (order) {\n    let items = {},\n      rootEl = this.el;\n\n    this.toArray().forEach(function (id, i) {\n      let el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function () {\n    let store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function (el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function (name, value) {\n    let options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      let modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== \"undefined\") {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === \"group\") {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function () {\n    pluginEvent(\"destroy\", this);\n    let el = this.el;\n\n    el[expando] = null;\n\n    off(el, \"mousedown\", this._onTapStart);\n    off(el, \"touchstart\", this._onTapStart);\n    off(el, \"pointerdown\", this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, \"dragover\", this);\n      off(el, \"dragenter\", this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll(\"[draggable]\"), function (\n      el\n    ) {\n      el.removeAttribute(\"draggable\");\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n\n    this.el = el = null;\n  },\n\n  _hideClone: function () {\n    if (!cloneHidden) {\n      pluginEvent(\"hideClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      css(cloneEl, \"display\", \"none\");\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n\n  _showClone: function (putSortable) {\n    if (putSortable.lastPutMode !== \"clone\") {\n      this._hideClone();\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent(\"showClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, \"display\", \"\");\n      cloneHidden = false;\n    }\n  },\n};\n\nfunction _globalDragOver(/**Event*/ evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = \"move\";\n  }\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction onMove(\n  fromEl,\n  toEl,\n  dragEl,\n  dragRect,\n  targetEl,\n  targetRect,\n  originalEvent,\n  willInsertAfter\n) {\n  let evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(\"move\", {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(\"move\", true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  //@ts-ignore\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n\n  evt.originalEvent = originalEvent;\n\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  //@ts-ignore\n  let rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  const spacer = 10;\n\n  return vertical\n    ? evt.clientX > rect.right + spacer ||\n        (evt.clientX <= rect.right &&\n          evt.clientY > rect.bottom &&\n          evt.clientX >= rect.left)\n    : (evt.clientX > rect.right && evt.clientY > rect.top) ||\n        (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);\n}\n\nfunction _getSwapDirection(\n  evt,\n  target,\n  targetRect,\n  vertical,\n  swapThreshold,\n  invertedSwapThreshold,\n  invertSwap,\n  isLastTarget\n) {\n  let mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (\n        !pastFirstInvertThresh &&\n        (lastDirection === 1\n          ? mouseOnAxis > targetS1 + (targetLength * invertedSwapThreshold) / 2\n          : mouseOnAxis < targetS2 - (targetLength * invertedSwapThreshold) / 2)\n      ) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (\n          lastDirection === 1\n            ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n            : mouseOnAxis > targetS2 - targetMoveDistance\n        ) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (\n        mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&\n        mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2\n      ) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (\n      mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||\n      mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2\n    ) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\nfunction _getInsertDirection(target) {\n  //@ts-ignore\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\nfunction _generateId(el) {\n  let str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n\n  let inputs = root.getElementsByTagName(\"input\");\n  let idx = inputs.length;\n\n  while (idx--) {\n    let el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, \"touchmove\", function (evt) {\n    //@ts-ignore\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function (el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n};\n\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\nSortable.mount = function (...plugins) {\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n\n  plugins.forEach((plugin) => {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw `Sortable: Mounted plugin must be a constructor function, not ${{}.toString.call(\n        plugin\n      )}`;\n    }\n    if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nexport default Sortable;\n","import { toggleClass, index } from \"../../../utils/src\";\n\nlet lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\",\n    };\n  }\n\n  Swap.prototype = {\n    dragStart({ dragEl }) {\n      lastSwapEl = dragEl;\n    },\n    dragOverValid({\n      completed,\n      target,\n      onMove,\n      activeSortable,\n      changed,\n      cancel,\n    }) {\n      if (!activeSortable.options.swap) return;\n      let el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        let prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n\n      completed(true);\n      cancel();\n    },\n    drop({ activeSortable, putSortable, dragEl }) {\n      let toSortable = putSortable || this.sortable;\n      let options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (\n        lastSwapEl &&\n        (options.swap || (putSortable && putSortable.options.swap))\n      ) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable)\n            activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling() {\n      lastSwapEl = null;\n    },\n  };\n\n  return Object.assign(Swap, {\n    pluginName: \"swap\",\n    eventProperties() {\n      return {\n        swapItem: lastSwapEl,\n      };\n    },\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  let p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n\n  //@ts-ignore\n  i1 = index(n1);\n  //@ts-ignore\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nexport default SwapPlugin;\n","import {\n  getRect,\n  css,\n  matrix,\n  isRectEqual,\n  indexOfObject,\n} from \"../../utils/src\";\nimport * as Sortable from \"./Sortable\";\n\nexport default function AnimationStateManager() {\n  let animationStates = [],\n    animationCallbackId;\n\n  return {\n    captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      let children = [].slice.call(this.el.children);\n\n      children.forEach((child) => {\n        //@ts-ignore\n        if (css(child, \"display\") === \"none\" || child === Sortable.ghost)\n          return;\n        animationStates.push({\n          target: child,\n          //@ts-ignore\n          rect: getRect(child),\n        });\n        let fromRect = { ...animationStates[animationStates.length - 1].rect };\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          let childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n\n    addAnimationState(state) {\n      animationStates.push(state);\n    },\n\n    removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, { target }), 1);\n    },\n\n    animateAll(callback) {\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === \"function\") callback();\n        return;\n      }\n\n      let animating = false,\n        animationTime = 0;\n\n      animationStates.forEach((state) => {\n        let time = 0,\n          animatingThis = false,\n          target = state.target,\n          fromRect = target.fromRect,\n          //@ts-ignore\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (\n            isRectEqual(prevFromRect, toRect) &&\n            !isRectEqual(fromRect, toRect) &&\n            // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) /\n              (animatingRect.left - toRect.left) ===\n              (fromRect.top - toRect.top) / (fromRect.left - toRect.left)\n          ) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(\n              animatingRect,\n              prevFromRect,\n              prevToRect,\n              this.options\n            );\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = this.options.animation;\n          }\n          this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === \"function\") callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === \"function\") callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n\n    animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, \"transition\", \"\");\n        css(target, \"transform\", \"\");\n        //@ts-ignore\n        let elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n\n        css(\n          target,\n          \"transform\",\n          \"translate3d(\" + translateX + \"px,\" + translateY + \"px,0)\"\n        );\n\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(\n          target,\n          \"transition\",\n          \"transform \" +\n            duration +\n            \"ms\" +\n            (this.options.easing ? \" \" + this.options.easing : \"\")\n        );\n        css(target, \"transform\", \"translate3d(0,0,0)\");\n        typeof target.animated === \"number\" && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, \"transition\", \"\");\n          css(target, \"transform\", \"\");\n          target.animated = false;\n\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    },\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return (\n    (Math.sqrt(\n      Math.pow(fromRect.top - animatingRect.top, 2) +\n        Math.pow(fromRect.left - animatingRect.left, 2)\n    ) /\n      Math.sqrt(\n        Math.pow(fromRect.top - toRect.top, 2) +\n          Math.pow(fromRect.left - toRect.left, 2)\n      )) *\n    options.animation\n  );\n}\n","import {\n  toggleClass,\n  getRect,\n  index,\n  closest,\n  on,\n  off,\n  clone,\n  css,\n  setRect,\n  unsetRect,\n  matrix,\n  expando,\n} from \"../../../utils/src\";\n\nimport dispatchEvent from \"../../../sortable/src/EventDispatcher\";\n\nlet multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect, // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false, // Initial multi-drag fold when drag started\n  folding = false, // Folding any other time\n  dragStarted = false,\n  dragEl,\n  clonesFromRect,\n  clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, \"pointerup\", this._deselectMultiDrag);\n    } else {\n      on(document, \"mouseup\", this._deselectMultiDrag);\n      on(document, \"touchend\", this._deselectMultiDrag);\n    }\n\n    on(document, \"keydown\", this._checkKeyDown);\n    on(document, \"keyup\", this._checkKeyUp);\n\n    this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData(dataTransfer, dragEl) {\n        let data = \"\";\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach((multiDragElement, i) => {\n            data += (!i ? \"\" : \", \") + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData(\"Text\", data);\n      },\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n\n    delayStartGlobal({ dragEl: dragged }) {\n      dragEl = dragged;\n    },\n\n    delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl);\n    },\n\n    setupClone({ sortable, cancel }) {\n      if (!this.isMultiDrag) return;\n      for (let i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style[\"will-change\"] = \"\";\n\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl &&\n          toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n      cancel();\n    },\n\n    clone({ sortable, rootEl, dispatchSortableEvent, cancel }) {\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent(\"clone\");\n\n          cancel();\n        }\n      }\n    },\n\n    showClone({ cloneNowShown, rootEl, cancel }) {\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"\");\n      });\n\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n\n    hideClone({ sortable, cloneNowHidden, cancel }) {\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"none\");\n        if (this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n\n    dragStartGlobal({ sortable }) {\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach((multiDragElement) => {\n        //@ts-ignore\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n\n    dragStarted({ sortable }) {\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            css(multiDragElement, \"position\", \"absolute\");\n          });\n\n          //@ts-ignore\n          let dragRect = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRect);\n          });\n\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(() => {\n        folding = false;\n        initialFolding = false;\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (this.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n\n    dragOver({ target, completed, cancel }) {\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n\n    revert({ fromSortable, rootEl, sortable, dragRect }) {\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach((multiDragElement) => {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            //@ts-ignore\n            rect: folding ? getRect(multiDragElement) : dragRect,\n          });\n\n          unsetRect(multiDragElement);\n\n          multiDragElement.fromRect = dragRect;\n\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n\n    dragOverCompleted({\n      sortable,\n      isOwner,\n      insertion,\n      activeSortable,\n      parentEl,\n      putSortable,\n    }) {\n      let options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (\n          options.animation &&\n          multiDragElements.length > 1 &&\n          (folding ||\n            (!isOwner && !activeSortable.options.sort && !putSortable))\n        ) {\n          //@ts-ignore\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          let dragRectAbsolute = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            let clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (\n              activeSortable.options.animation &&\n              !clonesHidden &&\n              clonesHiddenBefore\n            ) {\n              multiDragClones.forEach((clone) => {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect,\n                });\n\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n\n    dragOverAnimationCapture({ dragRect, isOwner, activeSortable }) {\n      multiDragElements.forEach((multiDragElement) => {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (\n        activeSortable.options.animation &&\n        !isOwner &&\n        activeSortable.multiDrag.isMultiDrag\n      ) {\n        clonesFromRect = Object.assign({}, dragRect);\n        let dragMatrix = matrix(dragEl, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n\n    dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n\n    drop({\n      originalEvent: evt,\n      rootEl,\n      parentEl,\n      sortable,\n      dispatchSortableEvent,\n      oldIndex,\n      putSortable,\n    }) {\n      let toSortable = putSortable || this.sortable;\n\n      if (!evt) return;\n\n      let options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(\n          dragEl,\n          options.selectedClass,\n          !~multiDragElements.indexOf(dragEl)\n        );\n\n        if (!~multiDragElements.indexOf(dragEl)) {\n          multiDragElements.push(dragEl);\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"select\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (\n            evt.shiftKey &&\n            lastMultiDragSelect &&\n            sortable.el.contains(lastMultiDragSelect)\n          ) {\n            //@ts-ignore\n            let lastIndex = index(lastMultiDragSelect),\n              //@ts-ignore\n              currentIndex = index(dragEl);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              let n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n\n                dispatchEvent({\n                  sortable,\n                  rootEl,\n                  name: \"select\",\n                  targetEl: children[i],\n                  //@ts-ignore\n                  originalEvt: evt,\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"deselect\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if (\n          (parentEl[expando].options.sort || parentEl !== rootEl) &&\n          multiDragElements.length > 1\n        ) {\n          //@ts-ignore\n          let dragRect = getRect(dragEl),\n            multiDragIndex = index(\n              dragEl,\n              \":not(.\" + this.options.selectedClass + \")\"\n            );\n\n          if (!initialFolding && options.animation)\n            dragEl.thisAnimationDuration = null;\n\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl.fromRect = dragRect;\n              multiDragElements.forEach((multiDragElement) => {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl) {\n                  //@ts-ignore\n                  let rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect,\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n\n            multiDragElements.forEach((multiDragElement) => {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(\n                  multiDragElement,\n                  children[multiDragIndex]\n                );\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            //@ts-ignore\n            if (oldIndex === index(dragEl)) {\n              let update = false;\n              multiDragElements.forEach((multiDragElement) => {\n                //@ts-ignore\n                if (\n                  //@ts-ignore\n                  multiDragElement.sortableIndex !== index(multiDragElement)\n                ) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent(\"update\");\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        multiDragClones.forEach((clone) => {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n\n    nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n\n    destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, \"pointerup\", this._deselectMultiDrag);\n      off(document, \"mouseup\", this._deselectMultiDrag);\n      off(document, \"touchend\", this._deselectMultiDrag);\n\n      off(document, \"keydown\", this._checkKeyDown);\n      off(document, \"keyup\", this._checkKeyUp);\n    },\n\n    _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (\n        evt &&\n        closest(evt.target, this.options.draggable, this.sortable.el, false)\n      )\n        return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        let el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          //@ts-ignore\n          targetEl: el,\n          //@ts-ignore\n          originalEvt: evt,\n        });\n      }\n    },\n\n    _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n\n    _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    },\n  };\n\n  return Object.assign(MultiDrag, {\n    // Static methods & properties\n    pluginName: \"multiDrag\",\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select(el) {\n        let sortable = el.parentNode[expando];\n        if (\n          !sortable ||\n          !sortable.options.multiDrag ||\n          ~multiDragElements.indexOf(el)\n        )\n          return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect(el) {\n        let sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      },\n    },\n    eventProperties() {\n      const oldIndicies = [],\n        newIndicies = [];\n\n      multiDragElements.forEach((multiDragElement) => {\n        oldIndicies.push({\n          multiDragElement,\n          index: multiDragElement.sortableIndex,\n        });\n\n        // multiDragElements will already be sorted if folding\n        let newIndex;\n        if (folding && multiDragElement !== dragEl) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(\n            multiDragElement,\n            \":not(.\" + this.options.selectedClass + \")\"\n          );\n        } else {\n          //@ts-ignore\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement,\n          index: newIndex,\n        });\n      });\n      return {\n        items: [...multiDragElements],\n        clones: [...multiDragClones],\n        oldIndicies,\n        newIndicies,\n      };\n    },\n    optionListeners: {\n      multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === \"ctrl\") {\n          key = \"Control\";\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      },\n    },\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach((multiDragElement, i) => {\n    let target =\n      rootEl.children[\n        multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)\n      ];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach((clone, i) => {\n    let target =\n      rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach((multiDragElement) => {\n    if (multiDragElement === dragEl) return;\n    multiDragElement.parentNode &&\n      multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nexport default MultiDragPlugin;\n","import {\n  on,\n  off,\n  css,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  getParentAutoScrollElement,\n  expando,\n  getRect,\n  getWindowScrollingElement,\n  Edge,\n  IE11OrLess,\n  Safari,\n} from \"../../../utils/src\";\n\nimport Sortable from \"../../../sortable/src/Sortable\";\n\nlet autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt,\n  pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true,\n    };\n\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted({ originalEvent }) {\n      if (this.sortable.nativeDraggable) {\n        on(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, \"pointermove\", this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, \"touchmove\", this._handleFallbackAutoScroll);\n        } else {\n          on(document, \"mousemove\", this._handleFallbackAutoScroll);\n        }\n      }\n    },\n\n    dragOverCompleted({ originalEvent }) {\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n\n    drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        off(document, \"pointermove\", this._handleFallbackAutoScroll);\n        off(document, \"touchmove\", this._handleFallbackAutoScroll);\n        off(document, \"mousemove\", this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n\n    nulling() {\n      touchEvt = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n\n      autoScrolls.length = 0;\n    },\n\n    _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n\n    _handleAutoScroll(evt, fallback) {\n      const x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n\n      touchEvt = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || Edge || IE11OrLess || Safari) {\n        //@ts-ignore\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        let ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (\n          scrolling &&\n          (!pointerElemChangedInterval ||\n            x !== lastAutoScrollX ||\n            y !== lastAutoScrollY)\n        ) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(() => {\n            let newElem = getParentAutoScrollElement(\n              document.elementFromPoint(x, y),\n              true\n            );\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            //@ts-ignore\n            autoScroll(evt, this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (\n          !this.options.bubbleScroll ||\n          getParentAutoScrollElement(elem, true) === getWindowScrollingElement()\n        ) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(\n          //@ts-ignore\n          evt,\n          this.options,\n          getParentAutoScrollElement(elem, false),\n          false\n        );\n      }\n    },\n  };\n\n  return Object.assign(AutoScroll, {\n    pluginName: \"scroll\",\n    initializeByDefault: true,\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nconst autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  const x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n\n  let scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n\n    clearAutoScrolls();\n\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  let layersOut = 0;\n  let currentParent = scrollEl;\n  do {\n    let el = currentParent,\n      //@ts-ignore\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX,\n      canScrollY,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      //@ts-ignore\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" ||\n          elCSS.overflowX === \"scroll\" ||\n          elCSS.overflowX === \"visible\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" ||\n          elCSS.overflowY === \"scroll\" ||\n          elCSS.overflowY === \"visible\");\n    } else {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" || elCSS.overflowX === \"scroll\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" || elCSS.overflowY === \"scroll\");\n    }\n\n    let vx =\n      canScrollX &&\n      //@ts-ignore\n      (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -\n        //@ts-ignore\n        (Math.abs(left - x) <= sens && !!scrollPosX);\n    let vy =\n      canScrollY &&\n      //@ts-ignore\n      (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -\n        //@ts-ignore\n        (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (let i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (\n      autoScrolls[layersOut].vx != vx ||\n      autoScrolls[layersOut].vy != vy ||\n      autoScrolls[layersOut].el !== el\n    ) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(\n          function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              //@ts-ignore\n              Sortable.active._onTouchMove(touchEvt); // To move ghost if it is positioned absolutely\n            }\n            let scrollOffsetY = autoScrolls[this.layer].vy\n              ? autoScrolls[this.layer].vy * speed\n              : 0;\n            let scrollOffsetX = autoScrolls[this.layer].vx\n              ? autoScrolls[this.layer].vx * speed\n              : 0;\n\n            if (typeof scrollCustomFn === \"function\") {\n              if (\n                scrollCustomFn.call(\n                  //@ts-ignore\n                  Sortable.dragged.parentNode[expando],\n                  scrollOffsetX,\n                  scrollOffsetY,\n                  evt,\n                  touchEvt,\n                  autoScrolls[this.layer].el\n                ) !== \"continue\"\n              ) {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({ layer: layersOut }),\n          24\n        );\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nexport default AutoScrollPlugin;\n","import { getChild } from \"../../../utils/src\";\n\nconst drop = function ({\n  originalEvent,\n  putSortable,\n  dragEl,\n  activeSortable,\n  dispatchSortableEvent,\n  hideGhostForTarget,\n  unhideGhostForTarget,\n}) {\n  if (!originalEvent) return;\n  let toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  let touch =\n    originalEvent.changedTouches && originalEvent.changedTouches.length\n      ? originalEvent.changedTouches[0]\n      : originalEvent;\n  let target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent(\"spill\");\n    this.onSpill({ dragEl, putSortable });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart({ oldDraggableIndex }) {\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill({ dragEl, putSortable }) {\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    let nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop,\n};\n\nObject.assign(Revert, {\n  pluginName: \"revertOnSpill\",\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill({ dragEl, putSortable }) {\n    const parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop,\n};\n\nObject.assign(Remove, {\n  pluginName: \"removeOnSpill\",\n});\n\nexport default [Remove, Revert];\n\nexport { Remove as RemoveOnSpill, Revert as RevertOnSpill };\n","import Sortable from \"../../sortable/src/Sortable\";\nimport Swap from \"../../plugins/swap/src\";\nimport MultiDrag from \"../../plugins/multi-drag/src\";\nimport AutoScroll from \"../../plugins/auto-scroll/src\";\n\nimport { RemoveOnSpill, RevertOnSpill } from \"../../plugins/on-spill/src\";\n\n//@ts-ignore\nSortable.mount(new AutoScroll());\nSortable.mount(RemoveOnSpill, RevertOnSpill);\n\nexport default Sortable;\nexport { Sortable, Swap, MultiDrag };\n"],"names":["userAgent","pattern","window","navigator","match","IE11OrLess","Edge","FireFox","Safari","IOS","ChromeForAndroid","captureMode","capture","passive","on","el","event","fn","addEventListener","off","removeEventListener","matches","selector","substring","msMatchesSelector","webkitMatchesSelector","_","getParentOrHost","host","document","nodeType","parentNode","closest","ctx","includeCTX","_throttleTimeout","R_SPACE","toggleClass","name","state","classList","className","replace","css","prop","val","style","defaultView","getComputedStyle","currentStyle","indexOf","matrix","selfOnly","appliedTransforms","transform","matrixFn","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","find","tagName","iterator","list","getElementsByTagName","i","n","length","getWindowScrollingElement","scrollingElement","documentElement","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","container","getBoundingClientRect","elRect","top","left","bottom","right","height","width","innerHeight","innerWidth","containerRect","parseInt","elMatrix","scaleX","a","scaleY","d","isScrolledPast","elSide","parentSide","parent","getParentAutoScrollElement","elSideVal","parentSideVal","getChild","childNum","options","currentChild","children","display","Sortable","ghost","dragged","draggable","lastChild","last","lastElementChild","previousElementSibling","index","nodeName","toUpperCase","clone","getRelativeScrollOffset","offsetLeft","offsetTop","winScroller","scrollLeft","scrollTop","includeSelf","elem","gotSelf","clientWidth","scrollWidth","clientHeight","scrollHeight","elemCSS","overflowX","overflowY","body","isRectEqual","rect1","rect2","Math","round","throttle","callback","ms","args","arguments","_this","this","call","apply","setTimeout","scrollBy","x","y","Polymer","$","jQuery","Zepto","dom","cloneNode","setRect","rect","unsetRect","expando","Date","getTime","plugins","defaults","initializeByDefault","pluginManager","mount","plugin","option","hasOwnProperty","push","pluginEvent","eventName","sortable","evt","eventCanceled","cancel","eventNameGlobal","forEach","pluginName","initializePlugins","initialized","Object","assign","modified","modifyOption","getEventProperties","eventProperties","value","modifiedValue","optionListeners","dispatchEvent","rootEl","targetEl","cloneEl","toEl","fromEl","oldIndex","newIndex","oldDraggableIndex","newDraggableIndex","originalEvent","putSortable","extraEventProperties","onName","charAt","substr","CustomEvent","createEvent","initEvent","bubbles","cancelable","to","from","item","pullMode","lastPutMode","undefined","allEventProperties","PluginManager","data","bind","dragEl","parentEl","ghostEl","nextEl","lastDownEl","cloneHidden","dragStarted","moved","activeSortable","active","hideGhostForTarget","_hideGhostForTarget","unhideGhostForTarget","_unhideGhostForTarget","cloneNowHidden","cloneNowShown","dispatchSortableEvent","_dispatchEvent","info","activeGroup","tapEvt","touchEvt","lastDx","lastDy","tapDistanceLeft","tapDistanceTop","lastTarget","lastDirection","targetMoveDistance","ghostRelativeParent","awaitingDragStarted","ignoreNextClick","sortables","pastFirstInvertThresh","isCircumstantialInvert","ghostRelativeParentInitialScroll","_silent","savedInputChecked","documentExists","PositionGhostAbsolutely","CSSFloatProperty","supportDraggable","createElement","supportCssPointerEvents","cssText","pointerEvents","_detectDirection","elCSS","elWidth","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","child1","child2","firstChildCSS","secondChildCSS","firstChildWidth","marginLeft","marginRight","secondChildWidth","flexDirection","gridTemplateColumns","split","clear","_prepareGroup","toFn","pull","group","otherGroup","join","originalGroup","checkPull","checkPut","put","revertClone","preventDefault","stopPropagation","stopImmediatePropagation","lastSwapEl","nearestEmptyInsertDetectEvent","nearest","touches","clientX","clientY","some","threshold","emptyInsertThreshold","ret","target","_onDragOver","_checkOutsideTargetEl","_isOutsideThisEl","toString","animationCallbackId","animationStates","sort","disabled","store","handle","test","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","ghostClass","chosenClass","dragClass","ignore","filter","preventOnFilter","animation","easing","setData","dataTransfer","textContent","dropBubble","dragoverBubble","dataIdAttr","delay","delayOnTouchOnly","touchStartThreshold","Number","devicePixelRatio","forceFallback","fallbackClass","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","nativeDraggable","_onTapStart","get","captureAnimationState","slice","child","fromRect","thisAnimationDuration","childMatrix","f","e","addAnimationState","removeAnimationState","splice","arr","obj","key","indexOfObject","animateAll","clearTimeout","animating","animationTime","time","toRect","prevFromRect","prevToRect","animatingRect","targetMatrix","sqrt","pow","calculateRealTime","animate","max","animationResetTimer","currentRect","duration","translateX","translateY","animatingX","animatingY","forRepaintDummy","offsetWidth","repaint","animated","onMove","dragRect","targetRect","willInsertAfter","retVal","onMoveFn","draggedRect","related","relatedRect","_disableDraggable","_unsilent","_generateId","str","src","href","sum","charCodeAt","_nextTick","_cancelNextTick","id","SwapPlugin","Swap","swapClass","prototype","dragStart","dragOverValid","completed","changed","swap","prevSwapEl","drop","n1","n2","i1","i2","p1","p2","toSortable","isEqualNode","insertBefore","nulling","swapItem","constructor","contains","_getDirection","type","touch","pointerType","originalTarget","shadowRoot","path","composedPath","root","inputs","idx","checked","_saveInputCheckedState","button","isContentEditable","criteria","trim","_prepareDragStart","dragStartFn","ownerDocument","nextSibling","_lastX","_lastY","_onDrop","_disableDelayedDragEvents","_triggerDragStart","_disableDelayedDrag","_delayedDragTouchMoveHandler","_dragStartTimer","abs","floor","_onTouchMove","_onDragStart","selection","empty","getSelection","removeAllRanges","err","_dragStarted","fallback","_appendGhost","_nulling","_emulateDragOver","elementFromPoint","ghostMatrix","relativeScrollOffset","dx","dy","b","c","cssMatrix","appendChild","_hideClone","cloneId","_loopId","setInterval","effectAllowed","_dragStartId","revert","vertical","isOwner","canSort","fromSortable","completedFired","dragOverEvent","_ignoreWhileAnimating","elLastChild","_ghostIsLast","targetBeforeFirstSwap","sibling","differentLevel","differentRowCol","dragElS1Opp","targetS1Opp","_dragElInRowColumn","side1","scrolledPastTop","scrollBefore","isLastTarget","mouseOnAxis","targetLength","targetS1","targetS2","invert","_getInsertDirection","_getSwapDirection","dragIndex","nextElementSibling","after","moveVector","extra","axis","insertion","_showClone","_offMoveEvents","_offUpEvents","clearInterval","removeChild","save","handleEvent","dropEffect","_globalDragOver","toArray","order","getAttribute","items","set","destroy","Array","querySelectorAll","removeAttribute","utils","is","extend","dst","nextTick","cancelNextTick","detectDirection","element","create","version","lastMultiDragSelect","multiDragSortable","clonesFromRect","clonesHidden","multiDragElements","multiDragClones","initialFolding","folding","MultiDragPlugin","MultiDrag","_deselectMultiDrag","_checkKeyDown","_checkKeyUp","selectedClass","multiDragKey","multiDragElement","multiDragKeyDown","isMultiDrag","delayStartGlobal","delayEnded","setupClone","sortableIndex","insertMultiDragClones","showClone","hideClone","dragStartGlobal","multiDrag","_this2","removeMultiDragElements","dragOver","clonesInserted","insertMultiDragElements","dragOverCompleted","dragRectAbsolute","clonesHiddenBefore","dragOverAnimationCapture","dragMatrix","dragOverAnimationComplete","originalEvt","shiftKey","lastIndex","currentIndex","multiDragIndex","update","nullingGlobal","destroyGlobal","shift","select","deselect","oldIndicies","newIndicies","_this3","clones","toLowerCase","elementsInserted","scrollEl","scrollRootEl","lastAutoScrollX","lastAutoScrollY","pointerElemChangedInterval","autoScrolls","scrolling","clearAutoScrolls","autoScroll","pid","clearPointerElemChangedInterval","isFallback","scroll","scrollCustomFn","sens","scrollSensitivity","speed","scrollSpeed","scrollThisInstance","scrollFn","layersOut","currentParent","canScrollX","canScrollY","scrollPosX","scrollPosY","vx","vy","layer","scrollOffsetY","scrollOffsetX","bubbleScroll","changedTouches","onSpill","Revert","Remove","startIndex","parentSortable","AutoScroll","_handleAutoScroll","_handleFallbackAutoScroll","dragOverBubble","ogElemScroller","newElem","RemoveOnSpill","RevertOnSpill"],"mappings":"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"}